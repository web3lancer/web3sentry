"""
Smart Contract Vulnerability Detector Module.

This module helps identify potential security vulnerabilities in smart contract interactions.
It's like having a security expert review each contract your transactions interact with!
"""
from typing import Dict, Any, List
import logging
import re

# Import our base detector
try:
    from web3sentry.detectors.base_detector import BaseDetector
except ImportError:
    # Fallback for development 
    from detectors.base_detector import BaseDetector

logger = logging.getLogger(__name__)

class ContractVulnerabilityDetector(BaseDetector):
    """Detector for common smart contract vulnerabilities.
    
    This detector looks for interactions with contracts that might have
    vulnerabilities like reentrancy issues, integer overflow/underflow,
    or other common security problems.
    """
    
    def __init__(self):
        """Initialize the vulnerability detector.
        
        Sets up our list of vulnerable patterns to watch for.
        """
        super().__init__(
            name="Contract Vulnerability Detector",
            description="Identifies potentially vulnerable smart contract interactions"
        )
        # In a real system, we'd have an actual database of vulnerable contracts
        # For now, we'll just use some example patterns
        self.vulnerable_patterns = {
            "reentrancy": [
                "0x7a250d5630b4cf539739df2c5dacb4c659f2488d",  # Just an example
            ],
            "overflow": [
                "0x1234567890abcdef1234567890abcdef12345678",  # Just an example
            ]
        }
        
        # We might also keep track of verified safe contracts
        self.verified_safe = [
            "0xabcdef1234567890abcdef1234567890abcdef12",  # Just an example
        ]
        
    async def analyze(self, transaction_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Check if the transaction interacts with potentially vulnerable contracts.
        
        We look at the 'to' address to see if it matches any known vulnerable contracts,
        and check for patterns in the input data that might suggest risky operations.
        
        Args:
            transaction_data: The transaction details to analyze
            
        Returns:
            Analysis results with risk level and vulnerability details
        """
        # Start with the assumption that everything's ok
        risk_level = "LOW"
        details = []
        
        # Get the destination address of the transaction
        to_address = transaction_data.get("to", "").lower()
        
        # If this is a contract creation transaction, handle differently
        if not to_address:
            details.append("Contract creation transaction - review code carefully!")
            risk_level = "MEDIUM"
        else:
            # Check against our vulnerable contract patterns
            for vuln_type, addresses in self.vulnerable_patterns.items():
                if to_address in addresses:
                    risk_level = "HIGH"
                    details.append(f"Target contract has known {vuln_type} vulnerability - be careful!")
        
            # Input data can tell us a lot about what the transaction is doing
            input_data = transaction_data.get("input", "")
            if input_data.startswith("0x"):
                # Hey, look for function signatures that might be risky
                # This is super simplified - in real life we'd do proper signature analysis
                if input_data.startswith("0xa9059cbb"):  # Example ERC20 transfer
                    details.append("ERC20 transfer detected - seems normal")
                elif input_data.startswith("0x"):
                    # We'd have more specific checks here in a real detector
                    pass
        
            # If it's a verified safe contract, we can lower the risk assessment
            if to_address in self.verified_safe and risk_level == "LOW":
                details.append("Contract has been verified as safe - probably nothing to worry about")
        
        # Include method to improve this detector over time
        # In a real system, we'd learn from confirmed vulnerabilities
            
        return {
            "risk_level": risk_level,
            "details": details,
            "detector": self.name,
            "vulnerability_types": [k for k, v in self.vulnerable_patterns.items() if to_address in v]
        }
    
    def get_detector_info(self) -> Dict[str, Any]:
        """Return detector configuration information.
        
        Shows how many vulnerability patterns we're checking against.
        """
        info = super().get_detector_info()
        
        # Count how many vulnerable contracts we're checking
        total_vulnerable = sum(len(addrs) for addrs in self.vulnerable_patterns.values())
        
        info.update({
            "vulnerable_patterns": {
                "count": total_vulnerable,
                "types": list(self.vulnerable_patterns.keys())
            },
            "verified_safe_count": len(self.verified_safe)
        })
        return info